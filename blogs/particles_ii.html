<!doctype html>
<html>
  <head>
    <title>Particles II</title>
    <link rel="icon" href="../assets/icon.png">
    <link rel="stylesheet" href="../style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../highlight/styles/night-owl.min.css">
    <script src="../highlight/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
  </head>
  <body>
    <ul class="headerBar">
      <li class="headerli"><a href="../index.html">Home</a></li>
      <li class="headerli"><a href="../blog.html">Blog</a></li>
      <li class="headerli"><a href="../projects.html">Projects</a></li>
      <li class="headerli"><a href="../about.html">About</a></li>
    </ul>
    <h1>A Fast and Simple Particle System, Part 2</h1>
    <ol>
      <li>Introduction</li>
      <li>Vertex Shader</li>
      <li>Index List and Indirect Drawing</li>
      <li>Particle Culling</li>
      <li>Compaction</li>
      <li>SoA Layout</li>
      <li>Shared Memory</li>
      <li>Future Work</li>
    </ol>
    <h2>Introduction</h2>
    <p>
      The previous post in the series discussed motivation, and basic implementations (CPU and GPU) of a 2D particle system. Here, we will discuss optimizations.
    </p>
    <h2>Vertex Shader</h2>
    <p>
      What if we didn't have to read any vertex data in our vertex shader?
    </p>
    <pre><code class="language-glsl">
#version 460 core

... // declarations

layout(location = 0) out vec2 vTexCoord;

// triangle fan with vertices in [0, 1]
// 0x3 == 0b1100
// 0x9 == 0b1001
// `b` selects which two bits will be used
vec2 CreateQuad(in uint vertexID) {
    uint b = 1 &lt&lt vertexID;
    return vec2((0x3 & b) != 0, (0x9 & b) != 0);
}

void main() {
    vTexCoord = CreateQuad(gl_VertexID);
    vec2 aPos = vTexCoord - 0.5;

    ... // calculate gl_Position
}
    </code></pre>
    <p>
      We use the clever technique of encoding vertex positions into consecutive bits inspired by <a href="https://twitter.com/Donzanoid/status/616370134278606848" class="link">this post</a>. Invoking the shader remains simple as before.
    </p>
    <pre><code>
void BeginRenderParticleEmitters() {
    /* bind shader, set uniforms */
    glBindVertexArray(emptyVAO); // no vertex attributes needed!
}

void RenderParticleEmitter(const ParticleEmitter& emitter) {
    glBindBuffer(GL_SHADER_STORAGE_BUFFER, emitter.particleBuffer);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0);
    glDrawArraysInstanced(GL_TRIANGLE_FAN, 0, 4, emitter.numParticles);
}
    </code></pre>
    <p>
      This isn't necessarily a performance optimization, as we may be subverting the hardware's post-transform cache, or, more precisely, <a href="https://arbook.icg.tugraz.at/schmalstieg/Schmalstieg_351.pdf" class="link">a form of batching</a>. The performance benefits are mostly theoretical, as fan primitives contain enough information to get the same vertex reuse benefits as indexed drawing. More obvious is that we can avoid the memory access required for reading a vertex and index buffer.
    </p>
    <h2>Compaction</h2>
    <p>
      You might've noticed by now that we're wasting quite a bit of space with the current particle struct layout. Currently, each particle instance is 80 bytes.
    </p>
    <pre><code class="language-glsl">
struct Particle
{
    vec4 position;
    vec4 velocity;
    vec4 acceleration;
    vec4 color;
    vec2 scale;
    float life;
    int padding_01;
};
    </code></pre>
    <p>
      For one, <code>position</code>, <code>velocity</code>, and <code>acceleration</code> each waste a float for the sake of alignment. Second, we probably don't need a full 32-bit float for storing velocity and acceleration. Scale also doesn't need very much precision as it will be in very small range near zero practically 100% of the time.
    </p>
    <p>
      With that in mind, I think we can do with just <a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format#IEEE_754_half-precision_binary_floating-point_format:_binary16" class="link">3.3 decimal digits of precison</a> with no major loss in quality by using half floats. Similarly, <code>color</code> does not need to be four full-precision floats. Since it stores diffuse RGB and alpha, we can use regular normalized 8-bit unsigned integers easily. We'll be taking advantage of GLSL's packing and unpacking functions to make this work.
    </p>
    <p>
      Here's the improved result:
    </p>
    <pre><code class="language-glsl">
struct Particle
{
    // .w unused (padding)
    vec4 position;

    // unpackHalf2x16 x 3 to access vel/accel, uintBitsToFloat(.w) to access life
    uvec4 velocity_acceleration_life;

    // unpackHalf2x16 to access scale, unpackUnorm4x8 to access color
    uvec2 packedScale_packedColor;

    // eight hidden bytes of padding O_o
};
    </code></pre>
    <p>
      It ain't pretty, but we managed to reduce the size of our data by half to 40 bytes. Ignoring the hidden alignment, I'd say that's pretty good! This should give us a substantial improvement in update and rendering times because we can utilize our limited bandwidth more efficiently.
    </p>
    <p>
      Now, why did I ignore that hidden alignment? Because there is another optimization that can be made with regards to the layout that will let us ignore it and give other gains.
    </p>
    <h2>SoA Layout</h2>
    <p>
      The big daddy of data-oriented programming appears once again. So, why would we care about organizing our data into a struct of arrays instead of one array containing all of the data for a particle? To answer that question, let's take a look at how our memory access pattern utilizes the L1 cache. Here, we pretend a cache line is 64 bytes. This is true for some architectures, like GCN, but not for others. The same concepts apply for the others.
    </p>
    <img src="https://i.imgur.com/ez6N68V.png">
    <p>
      This is how the caches are organized when we access six particle instances in one thread. Note that each particle requires 56.25% (36/64 bytes) of a cache line, so about every 1.8 particles read, there is a cache miss. Well, if we use all of the data we fetch in the cache, then we have no choice but to accept this cost. Well, let's take a look at the data we access in the particle update shader. (Yes, I'm ignoring that position needs a fourth component for alignment. It is omitted here for simplicity)
    </p>
    <img src="https://i.imgur.com/BZtOVOy.png">
    <p>
      It looks like we're wasting eight whole bytes of cache per particle we read because the scale and color remain constant. That is 29% more cache misses than necessary.
    </p>
    <img src="https://i.imgur.com/gFJGtwZ.png">
    <p>
      The case is even worse for the vertex shader. Nearly half the data fetched is wasted as we only need position, scale, and color for rendering.
    </p>
    <p>
      The solution to this problem is hinted at by the name of this section: <strong>SoA Layout</strong>. By separating particle data into different arrays based on access, we can make maximum use of the caches provided to us.
    </p>
    <pre><code class="language-glsl">
// accessed in update and vertex shader
struct ParticleSharedData
{
    vec4 position;
};

// accessed in update shader only
struct ParticleUpdateData
{
    uvec4 velocity_acceleration_life;
};

// accessed in vertex shader only
struct ParticleRenderData
{
    uvec2 scaleX_colorY;
};
    </code></pre>
    <p>
      And how this looks in memory when packed into separate buffers...
    </p>
    <img src="https://i.imgur.com/1wm2eoB.png">
    <p>
      Now, getting efficient cache behavior is as simple as fetching only the data we require in a shader.
    </p>
    <img src="https://i.imgur.com/JyHamxP.png">
    <img src="https://i.imgur.com/i2cfNKN.png">
    <h2>Future Work</h2>
    <p>
      We aren't at the end of the optimizations that could be made.
      TODO: mention emitter frustum culling, precise per-particle culling, SW rasterization for small particles (mention Nanite), adding more particle attributes (like rotation, angular velocity), culling precipitation with shadow map, etc.
    </p>
  </body>
</html>