<!doctype html>
<html>
  <head>
    <title>Particles I</title>
    <link rel="icon" href="../assets/icon.png">
    <link rel="stylesheet" href="../style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../highlight/styles/night-owl.min.css">
    <script src="../highlight/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
  </head>
  <body>
    <ul class="headerBar">
      <li class="headerli"><a href="../index.html">Home</a></li>
      <li class="headerli"><a href="../blog.html">Blog</a></li>
      <li class="headerli"><a href="../projects.html">Projects</a></li>
      <li class="headerli"><a href="../about.html">About</a></li>
    </ul>
    <h1>A Fast and Simple Particle System, Part 1</h1>
    <img src="https://i.imgur.com/ykOuFZs.jpeg">
    <h2>Table of Contents</h2>
    <ol>
      <li>Introduction</li>
      <li>Naive CPU Implementation</li>
      <li>Compute Shaders</li>
      <li>Naive GPU Implementation</li>
      <li>Closing</li>
    </ol>
    <h2>Introduction</h2>
    <p>
      Welcome to the first of a two-part series about implementing and optimizing the particle system implemented in my cleverly-named game engine, <a class="link" href="https://github.com/JuanDiegoMontoya/Gengine">Gengine</a>. This post (part 1) will cover motivation, architecture, and a basic implementation.
    </p>
    <p>
      According to <a style="white-space:nowrap" class="link" href="https://en.wikipedia.org/wiki/Particle_system">Wikipedia</a>, particles are used to simulate various "fuzzy" phenomena. In my case, I was looking for a way of cheaply handling effects like rain, fire, smoke, and digging effects, while still being visually plausible. Eventually, as you'll see, this turned into a personal challenge to see how many particles I could update and render while still having 60 frames per second.
    </p>
    <h2>Naive CPU Implementation</h2>
    <p>
      A naive attempt to utilize instancing to draw particles may look like the following code. A fake implicitly-synchronized graphics API and unspecified external variables are used in this example to convey intent more clearly. I also intentionally omit details like handling particle creation to keep the snippet brief. In practice, particle handling code will be more complicated than this, but it should illustrate how CPU-driven particles may be implemented.
    </p>
    <pre><code class="language-cpp">// particle with simple attributes
struct Particle {
    vec4 color;
    vec3 position;
    vec3 velocity;

    void Update() { position += velocity; }
};

struct ParticleEmitter {
    vec4 color;
    vec3 minPosition, maxPosition;
    vec3 minVelocity, maxVelocity;

    uint32_t numParticles;
    Buffer particlesBuffer;
};

void UpdateEmitter(const ParticleEmitter& emitter) {
    Particle* particlesMapped = emitter.particlesBuffer.GetMappedPointer();

    for (size_t i = 0; i &lt emitter.numParticles; i++) {
        particlesMapped[i].Update();
    }

    emitter.particlesBuffer.UnmapPointer();
}

void RenderEmitter(const ParticleEmitter& emitter) {
    BindShader(particleShader);
    /* setup uniform data, like the view-projection matrix */
    BindVertexFormat(particleVertexFormat);
    BindVertexBuffer(quadGeometryVertexBuffer);
    BindIndexBuffer(quadGeometryIndexBuffer)
    BindInstancedBuffer(emitter.particlesBuffer);

    // draw all the particles in an emitter with a single draw call
    DrawInstanced(quadIndexCount, emitter.numParticles, 0, 0, 0);
}   </code></pre>
    <p>
      This approach is simple, and gives decent performance. However, the drawbacks are too great when trying to achieve maximum performance.
    </p>
    <ul>
      <li>
        Mapping a buffer every time an emitter is updated introduces a sync point in non-explicit APIs (OpenGL and D3D11), as the driver must wait for the buffer to no longer be in use on the GPU before giving you a pointer you can write to. This manifests as a bubble in activity on both the CPU and the GPU timeline. This phenomenon is also known as a <a href="https://shawnhargreaves.com/blog/stalling-the-pipeline.html" class="link">pipeline stall</a>.
     </li>
      <li>
        In explicit APIs, or if you use persistent mapping in OpenGL, you must do additional work to ensure the buffer region is not being used on the GPU before you write. This entails N-buffering your particle data (increasing memory footprint) and/or using sync objects to manually synchronize GPU reads and CPU writes.
      </li>
      <li>
        Even though the update method is simple, it can be a huge amount of work for a single thread to update all the particles of an emitter. One of the goals, after all, is to be able to have millions of particles!
      </li>
    </ul>
    <figure>
      <img src="../assets/pipeline_stall.png" class="center" style="max-width: 90%;">
      <figcaption>A graphics programmer's worst nightmare realized because you call glMapBuffer every frame</figcaption>
    </figure>
    <p>
      What can we do about these problems? Let's take a closer look to see what the code is doing here and analyze our needs.
    </p>
    <ul>
      <li>Every particle has the same, simple operation performed on it.</li>
      <li>All particles can be updated independently of one another. That is, no particle is dependent on another.</li>
      <li>The data lives on the GPU and is consumed by the GPU.</li>
    </ul>
    <p>
      Very interesting. We know a tool that is great for concurrently processing data. It's called multithreading! Our problem happens to be an <a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel" class="link">embarrassingly parallel</a> workload. However, the data still lives far, far away from the CPU, requiring that we synchronize access. If only there was a way to execute arbitrary code on the GPU itself!
    </p>
    <h2>Compute Shaders</h2>
    <p>
      As you might've guessed, compute shaders are the perfect tool for this task.
    </p>
    <p>
      It would be remiss to use compute shaders without considering their drawbacks. By going with a compute shader-based solution, we lose the ability to manipulate particles in a fine-grained way. Handling collision with terrain becomes difficult. Using compute shaders to update particles also means we will be taking a slice of the precious GPU timeline. In a GPU-bound application, this can mean that we actually decrease performance by using compute shaders (depending on the number of particles)! Another thing we must consider when using compute shaders is <i>where</i> in the timeline they appear. Without async compute, we may cause extra fill and drain time when the GPU switches from rasterization to compute workloads and vice versa.
    </p>
    <h2>GPU Implementation (unfinished)</h2>
    <p>
      See links at the end of Part 2 for more info.
    </p>
    <p>
      Here is the vertex shader used to draw billboard particles.
    </p>
    <pre><code>
#version 460 core

#include "particle.h"

layout(std430, binding = 0) readonly restrict buffer Particles {
    Particle particles[];
};

layout(location = 0) in vec2 aPos; // in [-0.5, 0.5]

layout(location = 0) uniform mat4 u_viewProj;
layout(location = 1) uniform vec3 u_cameraRight;
layout(location = 2) uniform vec3 u_cameraUp;

layout(location = 0) out vec2 vTexCoord;
layout(location = 1) out vec4 vColor;

void main() {
    vTexCoord = aPos + 0.5;

    int index = gl_InstanceID;

    Particle particle = particles[index];

    vec3 vertexPosition_worldspace =
        particle.position.xyz +
        u_cameraRight * aPos.x * particle.scale.x +
        u_cameraUp * aPos.y * particle.scale.y;

    gl_Position = u_viewProj * vec4(vertexPosition_worldspace, 1.0);
}
    </code></pre>
    <p>
      The fragment shader is dead simple.
    </p>
    <pre><code>
#version 460 core
layout(location = 0) in vec2 vTexCoord;
layout(location = 1) in vec4 vColor;

layout(location = 3, binding = 0) uniform sampler2D u_sprite;

layout(location = 0) out vec4 fragColor;

void main() {
    fragColor = texture(u_sprite, vTexCoord) * vColor;
}
    </code></pre>
    <h2>Closing</h2>
    The <a href="particles_ii.html" class="link">next post</a> discusses ways we can optimize the GPU implementation of this particle system.
  </body>
</html>